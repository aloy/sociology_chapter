sim.y   <- simulate(fm, nsim = 20)
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),]
Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 9")
sim.b1 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
b.t <-  HLMresid(refit.b.t, level = "county", standardize = TRUE)
sim.y   <- simulate(fm, nsim = 19)
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
b.t <-  HLMresid(refit.b.t, level = "county", standardize = TRUE)#
#
sim.y   <- simulate(fm, nsim = 19)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models
sim.b1 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,2]) # ranef(x)[[1]][,2])   ## a list of random slopes
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
fm <- lmer(log.radon ~ basement + uranium + (basement | county), data = radon)#
#
b <-  HLMresid(fm, level = "county", standardize = TRUE)#
# b <- ranef(fm)[[1]] # notice that this is actually a matrix#
#
sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")#
sim.b1 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,2]) # ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
b.t <-  HLMresid(refit.b.t, level = "county", standardize = TRUE)
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1] # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- transform(b.t, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- transform(b.t, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
library(grid)
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- transform(b.t, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
sim.b0 <- ddply(sim.b0[complete.cases(sim.b0),], .(.n), transform, band = sim_env(`(Intercept)`),
x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
b0 <- transform(b.t[complete.cases(b.t),], band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
head(bim.b0)
head(sim.b0)
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )
head(sim.b0)
summary(sim.b0)
sim.b0 <- ddply(sim.b0[complete.cases(sim.b0),], .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
summary(sim.b0)
b0 <- transform(b.t[complete.cases(b.t),], band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
b0
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
decrypt("P2SX 6lal Y8 5GhYaYG8 Fd")
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
b.t <-  HLMresid(refit.b.t, level = "county", standardize = TRUE)#
#
sim.y   <- simulate(fm, nsim = 19)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0[complete.cases(sim.b0),], .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- transform(b.t[complete.cases(b.t),], band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
b.t <-  HLMresid(refit.b.t, level = "county", standardize = TRUE)#
#
sim.y   <- simulate(fm, nsim = 19)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation
sim.b0
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
b.t <-  HLMresid(refit.b.t, level = "county", standardize = TRUE)#
#
sim.y   <- simulate(fm, nsim = 19)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) HLMresid(x, level = "county", standardize = TRUE)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation
summary(sim.b0)
sim.b0
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]
qqnorm(b.t)
qqnorm(b.t[,1])
qqnorm(b.t[,2])
b.t
qqnorm(b.t[,2])
qqnorm(b.t[,1])
refit.b.t
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]
refit.b.t
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]
refit.b.t
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]
y.b.t <- sim_t_hlm(fm)#
refit.b.t <-  refit(fm, y.b.t)#
b.t <- ranef(refit.b.t)[[1]]#
#
sim.y   <- simulate(fm, nsim = 19)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0[complete.cases(sim.b0),], .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- transform(b.t[complete.cases(b.t),], band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") +  #
	theme(panel.margin = unit(0, "lines"))
fm <- lmer(log.radon ~ basement + uranium + (1 | county) + (basement - 1 | county), data = radon)
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 20, e.dsn = "norm", b0.dsn = "exp", b1.dsn = "exp",#
	sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
sim.true <- sim_indep_ranef_hlm(fm, nsim = 1, e.dsn = "norm", #
	b0.dsn = "exp", b1.dsn = "exp", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 19, e.dsn = "norm", #
	b0.dsn = "norm", b1.dsn = "norm", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models
true.mod <- refit(fm, sim.true)
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
b0 <- ranef(true.mod)[[1]]
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 FE")
b0
b0 <- data.frame( ranef(true.mod)[[1]] )
b0
Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 3")
b <- data.frame( ranef(true.mod)[[1]] )
b0 <- transform(b, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))
Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
b0 <- transform(b, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
(Intercept)
decrypt("P2SX 6lal Y8 5GhYaYG8 F")
b0 <- transform(b, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))
sim.b1 <- llply(sim.mod, function(x) ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))
Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 du")
fm
b <- ranef(fm)[[1]] # notice that this is actually a matrix#
#
sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
b <- ranef(fm)[[1]] # notice that this is actually a matrix#
#
sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 Fu")
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 20, e.dsn = "norm", #
	b0.dsn = "norm", b1.dsn = "norm", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),]
Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
sim.b1 <- llply(sim.mod, function(x) ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
b <- ranef(fm)[[1]] # notice that this is actually a matrix#
#
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 20, e.dsn = "norm", #
	b0.dsn = "norm", b1.dsn = "norm", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)                        #
# sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")#
sim.b1 <- llply(sim.mod, function(x) ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 Fd")
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 20, e.dsn = "t", #
	b0.dsn = "norm", b1.dsn = "norm", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)                        #
# sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 Fy")
sim.b1 <- llply(sim.mod, function(x) ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 Fu")
b <- ranef(fm)[[1]] # notice that this is actually a matrix#
#
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 20, e.dsn = "t", #
	b0.dsn = "norm", b1.dsn = "norm", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)                        #
# sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")#
sim.b1 <- llply(sim.mod, function(x) ranef(x)[[1]][,2])   ## a list of random slopes#
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame#
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting#
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation#
#
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))#
#
b1 <- subset(sim.b1, .n == 20)#
sim.b1 <- sim.b1[-which(sim.b1$.n == 20),] #
#
# Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
lev2.marginal.var <- function(.model) {#
  y <- .model@y#
  X <- getME(.model, "X")#
  Z <- BlockZ(.model)#
  n <- nrow(X)#
  ngrps <- unname(sapply(.model@flist, function(x) length(levels(x))))#
  # Constructing V = Cov(Y)#
  sig0 <- attr(VarCorr(.model), "sc") # sigma(.model)#
  ZDZt <- sig0^2 * crossprod( .model@A )#
  R    <- Diagonal( n = n, x = sig0^2 )#
  D    <- kronecker( Diagonal(ngrps), bdiag(VarCorr(.model)) )#
  V    <- Diagonal(n) + ZDZt#
  # Inverting V#
  V.chol <- chol( V )#
  Vinv   <- chol2inv( V.chol )#
#
  bse <- crossprod( chol(Vinv) %*% Z %*% D ) # Marginal COV. used by Lange and Ryan#
  bse.diag <- diag(bse)#
#
  semat <- matrix(sqrt(bse.diag), ncol = 2, byrow = TRUE)#
#
  return(semat)#
}
fm
.model <- fm
res <- ranef(.model)[[1]]
semat <- lev2.marginal.var(.model)
BlockZ <- function(object) {#
  Z <- getME(object, "Z")#
  grp.size <- table(object@flist)#
  ngrps <- length(grp.size)#
  nranef <- dim(ranef(object)[[1]])[2]#
  base.ord <- seq(from = 1, by = ngrps, length.out = nranef)#
  ord <- base.ord + rep(0:(ngrps - 1), each = nranef)#
  perm.mat <- t(as(ord, "pMatrix"))#
  return(Z %*% perm.mat)#
}
semat <- lev2.marginal.var(.model)
semat
head(res / semat)
head(res)
head(semat)
RVAL <- res / semat
complete.cases(RVAL)
std_ranef <- function(.model) {#
	res <- ranef(.model)[[1]]#
	semat <- lev2.marginal.var(.model)#
	RVAL <- res / semat#
	return(RVAL)#
}
b <- std_ranef(fm) # notice that this is actually a matrix
head(b)
fm <- lmer(log.radon ~ basement + uranium + (basement | county), data = radon)
b <- std_ranef(fm) # notice that this is actually a matrix
fm <- lmer(log.radon ~ basement + uranium + (basement | county), data = radon)
head(b)
sim.b0 <- llply(sim.mod, function(x) std_ranef(x)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes
sim.y   <- simulate(fm, nsim = 19, seed = 9221632)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) std_ranef(x)[,1]) # ranef(x)[[1]][,1])   ## a list of random slopes
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame
names(sim.b0) <- c("sample", "(Intercept)")
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )
sim.b0 <- ddply(sim.b0[complete.cases(sim.b0),], .(.n), transform, band = sim_env(`(Intercept)`),
x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
b0 <- transform(b, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 F3")
sim.b1 <- llply(sim.mod, function(x) std_ranef(x)[,2]) # ranef(x)[[1]][,2])   ## a list of random slopes
sim.b1 <- melt( do.call("rbind", sim.b1) )[,-2]           ## changing to a data frame
names(sim.b1) <- c("sample", "basement")                  ## setting colnames for faceting
sim.b1        <- arrange(sim.b1, sample)                  ## ordering by simulation
sim.b1$.n <- as.numeric( str_extract(sim.b1$sample, "\\d+") )#
sim.b1 <- ddply(sim.b1, .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))
head(sim.b1)
sim.b1 <- ddply(sim.b1[complete.cases(sim.b1),], .(.n), transform, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))
b1 <- transform(b, band = sim_env(basement), #
	x = sort(qqnorm(basement, plot.it=FALSE)$x))
Lineup of random slopes#
qplot(sample = basement, data = b1, stat = "qq") %+%#
	lineup(true = b1, sample = sim.b1) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
decrypt("P2SX 6lal Y8 5GhYaYG8 du")
fm <- lmer(log.radon ~ basement + uranium + (1 | county) + (basement - 1 | county), data = radon)#
#
### INDEPENDENT RANDOM EFFECTS ####
#
b <- ranef(fm)[[1]] # notice that this is actually a matrix#
#
sim.y   <- sim_indep_ranef_hlm(fm, nsim = 20, e.dsn = "t", #
	b0.dsn = "norm", b1.dsn = "norm", sigma.err = 2, sigma.b0 = 1, sigma.b1 = 1)                        #
# sim.y   <- simulate(fm, nsim = 20)                        #
sim.mod <- apply(sim.y, 2, refit, object = fm)            ## a list of models#
#
sim.b0 <- llply(sim.mod, function(x) ranef(x)[[1]][,1])   ## a list of random slopes#
sim.b0 <- melt( do.call("rbind", sim.b0) )[,-2]           ## changing to a data frame#
names(sim.b0) <- c("sample", "(Intercept)")                 #
sim.b0        <- arrange(sim.b0, sample)                  ## ordering by simulation#
#
sim.b0$.n <- as.numeric( str_extract(sim.b0$sample, "\\d+") )#
sim.b0 <- ddply(sim.b0, .(.n), transform, band = sim_env(`(Intercept)`), #
	x = sort(qqnorm(`(Intercept)`, plot.it=FALSE)$x))#
#
b0 <- subset(sim.b0, .n == 20)#
sim.b0 <- sim.b0[-which(sim.b0$.n == 20),] #
#
# Lineup of random intercepts#
qplot(sample = X.Intercept., data = b0, stat = "qq") %+%#
	lineup(true = b0, sample = sim.b0) + #
	facet_wrap(~ .sample, ncol = 5) + #
	geom_ribbon(aes(x = x, ymin = band.lower, ymax = band.upper), alpha = .25) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
ls()
rm(list=ls())
setwd("~/Documents/Thesis/Dissertation/sociology_chapter/")#
load('data/ahd.RData') # data#
library(lme4)#
library(HLMdiag)#
library(ggplot2)#
library(grid)#
library(plyr)#
library(MASS)#
#
model <- lmer(sbvalue ~ treatment + week*baseline + I(week^2)*baseline + #
  (0 + week + I(week^2) | subject), data = ahd)
set.seed(123456789)#
#
## Simulating null data#
sims <- simulate(model, nsim = 19)#
#
## Refit#
refit_fm <- apply(sims, 2, refit, object = model)#
#
## Extract level-1 residuals#
sim_resids <- llply(refit_fm, function(x){#
	e <- resid(x)#
	subj <- x@frame$subject#
	return(data.frame(EB.resid = e, subject = subj))#
})#
#
true_resids <- data.frame(EB.resid = resid(model), subject = model@frame$subject)
pdf.options(reset = FALSE)#
pdf("figures/ahd_badcyclone5.pdf", width = 8.5, height = 11)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(5,4)))#
vplayout <- function(x, y){viewport(layout.pos.row = x, layout.pos.col = y)}#
realp <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, data = true_resids, #
               geom = "boxplot", xlab = "", ylab = "") + coord_flip() + #
                 ylim(-150, 150) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank())#
real.i <- 5 # sample(1:20, 1)#
j <- 0#
pos <- matrix(1:20, ncol = 4, byrow=T)#
for(i in 1:20){#
  if(i==real.i) { #
    if(!i %in% c(1,5,9,13,17)) realp <- realp + xlab(NULL)#
    if(!i %in% 17:20) realp <- realp + ylab(NULL)#
    print(realp, vp = vplayout(which(pos == i, arr.ind = TRUE)[1],#
                               which(pos == i, arr.ind = TRUE)[2]))#
  }#
  else{#
    j <- j + 1#
    p <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, #
               data = sim_resids[[j]], geom = "boxplot", xlab = "", ylab = "") + #
                 coord_flip() + ylim(-150, 150) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank())#
    if(!i %in% c(1,5,9,13,17)) p <- p + xlab(NULL)#
    if(!i %in% 17:20) p <- p + ylab(NULL)#
    print(p, vp = vplayout(which(pos == i, arr.ind = TRUE)[1], which(pos == i, arr.ind = TRUE)[2]))#
  }#
}#
dev.off()
dir()
pdf.options(reset = FALSE)#
pdf("figures/ahd_badcyclone5.pdf", width = 8.5, height = 11)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(5,4)))#
vplayout <- function(x, y){viewport(layout.pos.row = x, layout.pos.col = y)}#
realp <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, data = true_resids, #
               geom = "boxplot", xlab = "", ylab = "") + coord_flip() + #
                 ylim(-150, 150) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank())#
real.i <- 5 # sample(1:20, 1)#
j <- 0#
pos <- matrix(1:20, ncol = 4, byrow=T)#
for(i in 1:20){#
  if(i==real.i) { #
    if(!i %in% c(1,5,9,13,17)) realp <- realp + xlab(NULL)#
    if(!i %in% 17:20) realp <- realp + ylab(NULL)#
    print(realp, vp = vplayout(which(pos == i, arr.ind = TRUE)[1],#
                               which(pos == i, arr.ind = TRUE)[2]))#
  }#
  else{#
    j <- j + 1#
    p <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, #
               data = sim_resids[[j]], geom = "boxplot", xlab = "", ylab = "") + #
                 coord_flip() + ylim(-150, 150) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank())#
    if(!i %in% c(1,5,9,13,17)) p <- p + xlab(NULL)#
    if(!i %in% 17:20) p <- p + ylab(NULL)#
    print(p, vp = vplayout(which(pos == i, arr.ind = TRUE)[1], which(pos == i, arr.ind = TRUE)[2]))#
  }#
}#
dev.off()
model2 <- lmer(log(sbvalue) ~ treatment + week*baseline + I(week^2)*baseline + #
  (0 + week + I(week^2) | subject), data = ahd)#
## Simulating null data#
sims2 <- simulate(model2, nsim = 19)#
#
## Refit#
refit_fm2 <- apply(sims2, 2, refit, object = model2)#
#
## Extract level-1 residuals#
sim_resids2 <- llply(refit_fm2, function(x){#
	e <- resid(x)#
	subj <- x@frame$subject#
	return(data.frame(EB.resid = e, subject = subj))#
})#
#
true_resids2 <- data.frame(EB.resid = resid(model2), subject = model2@frame$subject)
pdf.options(reset = FALSE)#
pdf("figures/ahd_goodcyclone13.pdf", width = 8.5, height = 11)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(5,4)))#
vplayout <- function(x, y){viewport(layout.pos.row = x, layout.pos.col = y)}#
realp <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, data = true_resids2, #
               geom = "boxplot", xlab = " ", ylab = " ") + coord_flip() + #
                 ylim(-.5, .5) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank())#
real.i <- 13 # sample(1:20, 1)#
j <- 0#
pos <- matrix(1:20, ncol = 4, byrow=T)#
for(i in 1:20){#
  if(i==real.i) { #
    if(!i %in% c(1,5,9,13,17)) realp <- realp + xlab(NULL)#
    if(!i %in% 17:20) realp <- realp + ylab(NULL)#
    print(realp, vp = vplayout(which(pos == i, arr.ind = TRUE)[1],#
                               which(pos == i, arr.ind = TRUE)[2]))#
  }#
  else{#
    j <- j + 1#
    p <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, #
               data = sim_resids2[[j]], geom = "boxplot", xlab = " ", ylab = " ") + #
                 coord_flip() + ylim(-.5, .5) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank())#
    if(!i %in% c(1,5,9,13,17)) p <- p + xlab(NULL)#
    if(!i %in% 17:20) p <- p + ylab(NULL)#
    print(p, vp = vplayout(which(pos == i, arr.ind = TRUE)[1], which(pos == i, arr.ind = TRUE)[2]))#
  }#
}#
dev.off()
Checking between group homogeneity#
## Residuals from true model#
set.seed(123456789)#
#
## Simulating null data#
sims <- simulate(model, nsim = 19)#
#
## Refit#
refit_fm <- apply(sims, 2, refit, object = model)#
#
## Extract level-1 residuals#
sim_resids <- llply(refit_fm, function(x){#
	e <- resid(x)#
	subj <- x@frame$subject#
	return(data.frame(EB.resid = e, subject = subj))#
})#
#
true_resids <- data.frame(EB.resid = resid(model), subject = model@frame$subject)#
#
pdf.options(reset = FALSE)#
pdf("figures/ahd_badcyclone5.pdf", width = 8.5, height = 11)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(5,4)))#
vplayout <- function(x, y){viewport(layout.pos.row = x, layout.pos.col = y)}#
realp <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, data = true_resids, #
               geom = "boxplot", xlab = "", ylab = "") + coord_flip() + #
                 ylim(-150, 150) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank(), axis.ticks.x = element_blank())#
real.i <- 5 # sample(1:20, 1)#
j <- 0#
pos <- matrix(1:20, ncol = 4, byrow=T)#
for(i in 1:20){#
  if(i==real.i) { #
    if(!i %in% c(1,5,9,13,17)) realp <- realp + xlab(NULL)#
    if(!i %in% 17:20) realp <- realp + ylab(NULL)#
    print(realp, vp = vplayout(which(pos == i, arr.ind = TRUE)[1],#
                               which(pos == i, arr.ind = TRUE)[2]))#
  }#
  else{#
    j <- j + 1#
    p <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, #
               data = sim_resids[[j]], geom = "boxplot", xlab = "", ylab = "") + #
                 coord_flip() + ylim(-150, 150) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank(), axis.ticks.x = element_blank())#
    if(!i %in% c(1,5,9,13,17)) p <- p + xlab(NULL)#
    if(!i %in% 17:20) p <- p + ylab(NULL)#
    print(p, vp = vplayout(which(pos == i, arr.ind = TRUE)[1], which(pos == i, arr.ind = TRUE)[2]))#
  }#
}#
dev.off()
model2 <- lmer(log(sbvalue) ~ treatment + week*baseline + I(week^2)*baseline + #
  (0 + week + I(week^2) | subject), data = ahd)#
## Simulating null data#
sims2 <- simulate(model2, nsim = 19)#
#
## Refit#
refit_fm2 <- apply(sims2, 2, refit, object = model2)#
#
## Extract level-1 residuals#
sim_resids2 <- llply(refit_fm2, function(x){#
	e <- resid(x)#
	subj <- x@frame$subject#
	return(data.frame(EB.resid = e, subject = subj))#
})#
#
true_resids2 <- data.frame(EB.resid = resid(model2), subject = model2@frame$subject)#
#
pdf.options(reset = FALSE)#
pdf("figures/ahd_goodcyclone13.pdf", width = 8.5, height = 11)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(5,4)))#
vplayout <- function(x, y){viewport(layout.pos.row = x, layout.pos.col = y)}#
realp <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, data = true_resids2, #
               geom = "boxplot", xlab = " ", ylab = " ") + coord_flip() + #
                 ylim(-.5, .5) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank(), axis.ticks.x = element_blank())#
real.i <- 13 # sample(1:20, 1)#
j <- 0#
pos <- matrix(1:20, ncol = 4, byrow=T)#
for(i in 1:20){#
  if(i==real.i) { #
    if(!i %in% c(1,5,9,13,17)) realp <- realp + xlab(NULL)#
    if(!i %in% 17:20) realp <- realp + ylab(NULL)#
    print(realp, vp = vplayout(which(pos == i, arr.ind = TRUE)[1],#
                               which(pos == i, arr.ind = TRUE)[2]))#
  }#
  else{#
    j <- j + 1#
    p <- qplot(x = reorder(subject, EB.resid, IQR), y = EB.resid, #
               data = sim_resids2[[j]], geom = "boxplot", xlab = " ", ylab = " ") + #
                 coord_flip() + ylim(-.5, .5) + #
                 theme(plot.margin = unit(c(.1,.1,.1,.1), "cm"), axis.text.y = element_blank(),#
                 axis.text.x = element_blank(), axis.ticks.x = element_blank())#
    if(!i %in% c(1,5,9,13,17)) p <- p + xlab(NULL)#
    if(!i %in% 17:20) p <- p + ylab(NULL)#
    print(p, vp = vplayout(which(pos == i, arr.ind = TRUE)[1], which(pos == i, arr.ind = TRUE)[2]))#
  }#
}#
dev.off()
setwd("~/Documents/Thesis/Dissertation/sociology_chapter/")#
library(ggplot2)#
library(lme4)     # for modeling#
library(HLMdiag)  # for residuals#
library(mlmRev)   # for the exam data#
library(nullabor) # for lineups#
library(plyr)#
library(reshape2)#
library(stringr)#
#
# Initial model#
M1 <- lmer(normexam ~ standLRT + (1 | school), data = Exam)#
#
# Do we need a random slope? - We can compare the observed data to simulated data#
# to see if the model can generate data that look like the original.#
qplot(x = standLRT, y = normexam, data = Exam, geom = "smooth", group = school, se = F, method = "lm", colour = I("black"))#
#
# The "easy way" with smoothers, but alpha refers to the bands...#
m1.sims  <- simulate(M1, nsim = 19, seed = 1234)#
m1.refit <- lapply(m1.sims, refit, object = M1)#
m1.simy <- lapply(m1.refit, function(x) x@y)#
#
sim.y <- do.call("cbind", m1.simy)#
sim.y <- melt(sim.y)[,-1]#
names(sim.y) <- c(".n", "y")#
sim.y$.n <- as.numeric(str_extract(sim.y$.n, "\\d+"))#
sim.y$standLRT <- rep(Exam$standLRT, rep = 19)#
sim.y$school <- rep(Exam$school, rep = 19)#
#
true.y <- data.frame(y = Exam$normexam, standLRT = Exam$standLRT, school = Exam$school)
m1.sims  <- simulate(M1, nsim = 19, seed = 1234)#
m1.refit <- lapply(m1.sims, refit, object = M1)#
m1.simy <- lapply(m1.refit, function(x) x@y)#
#
sim.y <- do.call("cbind", m1.simy)#
sim.y <- melt(sim.y)[,-1]#
names(sim.y) <- c(".n", "y")#
sim.y$.n <- as.numeric(str_extract(sim.y$.n, "\\d+"))#
sim.y$standLRT <- rep(Exam$standLRT, rep = 19)#
sim.y$school <- rep(Exam$school, rep = 19)#
#
true.y <- data.frame(y = Exam$normexam, standLRT = Exam$standLRT, school = Exam$school)#
#
qplot(x = standLRT, y = y, data = true.y, group = school, geom = "smooth", #
	method = "lm", se=F, colour = I("black"), alpha = I(0.5)) %+% #
	lineup(true = true.y, samples = sim.y) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) +#
	theme(axis.text.y = element_blank(), axis.text.x = element_blank())
The "harder way" to get alpha working#
m1.fitted <- ddply(sim.y, .(.n, school), function(x) {#
	m <- lm(y ~ standLRT, data = x)#
	data.frame(x, fitted = fitted(m))#
})#
#
true.df <- subset(Exam, select = c(school, normexam, standLRT))#
colnames(true.df)[2] <- "y"#
true.fitted <- ddply(true.df, .(school), function(x) {#
	m <- lm(y ~ standLRT, data = x)#
	data.frame(x, fitted = fitted(m))	#
})
qplot(x = standLRT, y = fitted, data = true.fitted, group = school, #
	geom = "line", alpha = I(0.5)) %+% #
	lineup(true = true.fitted, samples = m1.fitted) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) +#
	theme(axis.text.y = element_blank(), axis.text.x = element_blank())#
#	xlab("standardized LRT score") + #
#	ylab("GCSE exam score")
qplot(x = standLRT, y = fitted, data = true.fitted, group = school, #
	geom = "line", alpha = I(0.5)) %+% #
	lineup(true = true.fitted, samples = m1.fitted) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) +#
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
		axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 FR")
ggsave("figures/normexam_fanned_lineup13.pdf")
-------------------------------------------------------------------------------#
# Script constructing lineups for use in a paper demonstrating their utility#
# in checking the assumptions for hierarchical linear models.#
##
# Adam Loy#
# May 2013#
##
# Data description: #
# prospective longitudinal study#
# 158 children who were classified as autism spectrum disorder children.#
# Variables: #
# * childid - child id#
# * vsae - Vineland socialization age equivalent#
# * sicdegp - Sequenced inventory of communication development expressive group,#
#	i.e., expressive language group (1 = low, 2 = medium, 3 = high)#
# * age - ages (2, 3, 5, 9, 13)#
# * agemom - age of mother when child was born#
# * gender - gender (1 = male, 2 = female)#
# * race - race (1 = white, 2 = non-white)#
# * bestest2 - diagnosis at age 2 (1 = autism, 2 = PDD, 3 = non-spectrum)#
# * bestest9 - diagnosis at age 9 (1 = autism, 2 = PDD, 3 = non-spectrum)#
# * bestviq - verbal IQ at age 2#
# * bestnviq - non-verbal IQ at age 2#
##
# Sources:#
# West, Welch, and Galecki (2006).#
#   Linear Mixed Models: A Practical Guide Using Statistical Software.#
##
# Anderson, D. K., Oti, R. S., Lord, C., & Welch, K. (2009).#
#	Patterns of Growth in Adaptive Social Abilities Among Children with #
#	Autism Spectrum Disorders. Journal of Abnormal Child Psychology, 37(7), #
#	1019–1034. doi:10.1007/s10802-009-9326-0#
# #
# Anderson, D. K., Lord, C., Risi, S., DiLavore, P. S., Shulman, C., #
#	Thurm, A., et al. (2007). Patterns of growth in verbal abilities among #
#	children with autism spectrum disorder. Journal of Consulting and Clinical #
#	Psychology, 75(4), 594–604. doi:10.1037/0022-006X.75.4.594#
#-------------------------------------------------------------------------------#
#
#-------------------------------------------------------------------------------#
# Preliminaries#
#-------------------------------------------------------------------------------#
#
setwd("~/Documents/Thesis/Dissertation/sociology_chapter/")#
library(ggplot2)#
library(lme4)     # for modeling#
library(HLMdiag)  # for residuals#
library(WWGbook)  # for half of data set - see ?autism#
library(nullabor) # for lineups#
library(plyr)#
library(reshape2)#
library(stringr)#
#
# Function to make lineups for explanatory variables less tedious - level 1#
data.lineup.explvar1 <- function(null.model, variable, data, nsim = 19, std = FALSE) {#
	mod.sims  <- simulate(null.model, nsim = nsim)#
	mod.refit <- lapply(mod.sims, refit, object = null.model)#
	if(std){#
		mod.sim.resid <- lapply(mod.refit, HLMresid, level = 1, #
			type = "EB", standardize = TRUE)#
	} else{#
		mod.sim.resid <- lapply(mod.refit, resid)#
	}#
#
	mod.sim.resid <- do.call("cbind", mod.sim.resid)#
	mod.sim.resid <- melt(mod.sim.resid)[,-1]#
	names(mod.sim.resid) <- c(".n", "residual")#
	mod.sim.resid$.n <- as.numeric(str_extract(mod.sim.resid $.n, "\\d+"))#
	mod.sim.resid <- cbind(mod.sim.resid, data[, variable])#
	names(mod.sim.resid)[-c(1:2)] <- variable#
	return(mod.sim.resid)#
}#
#
# Function to make lineups for explanatory variables less tedious - level 2#
data.lineup.explvar2 <- function(null.model, variable, data, nsim = 19) {#
	mod.sims  <- simulate(null.model, nsim = nsim)#
	mod.refit <- lapply(mod.sims, refit, object = null.model)#
	mod.sim.resid <- lapply(mod.refit, HLMresid, level = "childid")#
#
	mod.sim.resid <- do.call("rbind", mod.sim.resid)#
	mod.sim.resid$.n <- as.numeric(str_extract(rownames(mod.sim.resid), "\\d+"))#
	mod.sim.resid$childid <- str_extract(rownames(mod.sim.resid), "[.]\\d+")#
	mod.sim.resid$childid <- as.numeric(str_extract(mod.sim.resid$childid, "\\d+"))#
	mod.sim.resid <- cbind(mod.sim.resid, data[, variable])#
	names(mod.sim.resid)[-c(1:4)] <- variable#
	return(mod.sim.resid)#
}#
# Reading in more of the autism data set#
demographics <- read.csv("data/autism_demographics.csv")#
#
# combining the data sets#
autism.full <- merge(x = autism, y = demographics, by.x = c("childid", "sicdegp"),#
	by.y = c("newinit", "sicdegp"), all.x = TRUE)#
# Creating factors where necessary#
autism.full$sicdegp  <- factor(autism.full$sicdegp, labels = c("low", "med", "high"))#
autism.full$gender   <- factor(autism.full$gender, labels = c("male", "female"))#
autism.full$race     <- factor(autism.full$race, labels = c("white", "nonwhite"))#
autism.full$bestest2 <- factor(autism.full$bestest2, labels = c("autism", "pdd"))#
#
# Revel sicdegp#
# autism.full$sicdegp <- relevel(autism.full$sicdegp, ref = 3)#
#
# Center age at 2 years to interpret the intercept#
autism.full$age2 <- autism.full$age - 2#
#
# Taking the complete cases for our example#
autism.modframe <- subset(autism.full, #
	select = c(childid, sicdegp, age2, vsae, gender, race, bestest2))#
autism.modframe <- na.omit(autism.modframe)
M1 <- lmer(vsae ~ age2 + ( age2 - 1 | childid ), data = autism.modframe)
sicdegp#
# We can look at the level-1 residuals, though they may be less interesting#
M1.sim.sicdegp  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp", #
	data = autism.modframe, std = FALSE)#
M1.sim.sicdegp.std  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp",#
	 data = autism.modframe, std = TRUE)#
M1.true.sicdegp <- data.frame(residual = resid(M1), #
	sicdegp = autism.modframe$sicdegp)#
M1.true.sicdegp.std <- data.frame(residual = HLMresid(M1, level = 1, #
	standardize = TRUE), sicdegp = autism.modframe$sicdegp)
qplot(x = sicdegp, y = residual, data = M2.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M2.true.sicdegp, samples = M2.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab("level-1 residuals")
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab("level-1 residuals")
set.seed(9221632)
M1 <- lmer(vsae ~ age2 + ( age2 - 1 | childid ), data = autism.modframe)#
#
### sicdegp#
# We can look at the level-1 residuals, though they may be less interesting#
M1.sim.sicdegp  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp", #
	data = autism.modframe, std = FALSE)#
M1.sim.sicdegp.std  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp",#
	 data = autism.modframe, std = TRUE)#
M1.true.sicdegp <- data.frame(residual = resid(M1), #
	sicdegp = autism.modframe$sicdegp)#
M1.true.sicdegp.std <- data.frame(residual = HLMresid(M1, level = 1, #
	standardize = TRUE), sicdegp = autism.modframe$sicdegp)#
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab("level-1 residuals")
set.seed(9221632)#
#
M1 <- lmer(vsae ~ age2 + ( age2 - 1 | childid ), data = autism.modframe)#
#
### sicdegp#
# We can look at the level-1 residuals, though they may be less interesting#
M1.sim.sicdegp  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp", #
	data = autism.modframe, std = FALSE)#
M1.sim.sicdegp.std  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp",#
	 data = autism.modframe, std = TRUE)#
M1.true.sicdegp <- data.frame(residual = resid(M1), #
	sicdegp = autism.modframe$sicdegp)#
M1.true.sicdegp.std <- data.frame(residual = HLMresid(M1, level = 1, #
	standardize = TRUE), sicdegp = autism.modframe$sicdegp)#
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab(NULL) + xlab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
set.seed(9221632)#
#
M1 <- lmer(vsae ~ age2 + ( age2 - 1 | childid ), data = autism.modframe)#
#
### sicdegp#
# We can look at the level-1 residuals, though they may be less interesting#
M1.sim.sicdegp  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp", #
	data = autism.modframe, std = FALSE)#
M1.sim.sicdegp.std  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp",#
	 data = autism.modframe, std = TRUE)#
M1.true.sicdegp <- data.frame(residual = resid(M1), #
	sicdegp = autism.modframe$sicdegp)#
M1.true.sicdegp.std <- data.frame(residual = HLMresid(M1, level = 1, #
	standardize = TRUE), sicdegp = autism.modframe$sicdegp)#
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab(NULL) + xlab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), #
	position.legend = "none")
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab(NULL) + xlab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), #
	legend.position = "none")
set.seed(9221632)#
#
M1 <- lmer(vsae ~ age2 + ( age2 - 1 | childid ), data = autism.modframe)#
#
### sicdegp#
# We can look at the level-1 residuals, though they may be less interesting#
M1.sim.sicdegp  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp", #
	data = autism.modframe, std = FALSE)#
M1.sim.sicdegp.std  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp",#
	 data = autism.modframe, std = TRUE)#
M1.true.sicdegp <- data.frame(residual = resid(M1), #
	sicdegp = autism.modframe$sicdegp)#
M1.true.sicdegp.std <- data.frame(residual = HLMresid(M1, level = 1, #
	standardize = TRUE), sicdegp = autism.modframe$sicdegp)#
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab(NULL) + xlab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), #
	legend.position = "none")
ggsave("figures/sicdegp_level1_lineup5.pdf")
M2.sim.sicdegp2  <- data.lineup.explvar2(null.model = M2, variable = "sicdegp", #
	data = child.df)#
M2.true.sicdegp2 <- data.frame(ranef(M2)[[1]], sicdegp = child.df$sicdegp)#
names(M2.true.sicdegp2)[2] <- "I(age2^2)"#
#
qplot(x = sicdegp, y = age2, data = M2.true.sicdegp2, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M2.true.sicdegp2, samples = M2.sim.sicdegp2) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10)
autism.modframe$sicdegp <- relevel(autism.modframe$sicdegp, ref = 3)
sicdegp#
# We can look at the level-1 residuals, though they may be less interesting#
M1.sim.sicdegp  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp", #
	data = autism.modframe, std = FALSE)#
M1.sim.sicdegp.std  <- data.lineup.explvar1(null.model = M1, variable = "sicdegp",#
	 data = autism.modframe, std = TRUE)#
M1.true.sicdegp <- data.frame(residual = resid(M1), #
	sicdegp = autism.modframe$sicdegp)#
M1.true.sicdegp.std <- data.frame(residual = HLMresid(M1, level = 1, #
	standardize = TRUE), sicdegp = autism.modframe$sicdegp)#
qplot(x = sicdegp, y = residual, data = M1.true.sicdegp, geom = "boxplot", #
	fill = sicdegp, outlier.size = 0) %+% #
	lineup(true = M1.true.sicdegp, samples = M1.sim.sicdegp) + #
	facet_wrap( ~ .sample, ncol=5) + #
	ylim(-10, 10) + #
	ylab(NULL) + xlab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), #
	legend.position = "none")
decrypt("P2SX 6lal Y8 5GhYaYG8 3")
ggsave("figures/sicdegp_level1_lineup4.pdf")
Do we need to allow for correlation? Typically you would add the random effect, then#
# test for the correlation. So that is what we will try.#
M2 <- lmer(normexam ~ standLRT + (standLRT  | school), data = Exam)#
M3 <- lmer(normexam ~ standLRT + (standLRT - 1 | school) + (1 | school), data = Exam)#
#
## The lineup -need to compare simulated ranefs to ranefs of M2#
M3.sims  <- simulate(M3, nsim = 19)#
M3.refit <- lapply(M3.sims, refit, object = M3)#
M3.sim.ranef <- lapply(M3.refit, function(x) ranef(x)[[1]])#
#
M3.sim.ranef <- do.call("rbind", M3.sim.ranef)#
M3.sim.ranef$.n <- rownames(M3.sim.ranef)#
M3.sim.ranef$.n <- as.numeric(str_extract(M3.sim.ranef$.n, "\\d+"))#
#
true.M2.ranef <- ranef(M2)$school#
#
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab("age - 2") + #
	ylab(expression(paste((age - 2)^2)))
anova(M2, M3)
decrypt("P2SX 6lal Y8 5GhYaYG8 E")
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5)
The "easy way" with smoothers, but alpha refers to the bands...#
m1.sims  <- simulate(M1, nsim = 19, seed = 1234)#
m1.refit <- lapply(m1.sims, refit, object = M1)#
m1.simy <- lapply(m1.refit, function(x) x@y)#
#
sim.y <- do.call("cbind", m1.simy)#
sim.y <- melt(sim.y)[,-1]#
names(sim.y) <- c(".n", "y")#
sim.y$.n <- as.numeric(str_extract(sim.y$.n, "\\d+"))#
sim.y$standLRT <- rep(Exam$standLRT, rep = 19)#
sim.y$school <- rep(Exam$school, rep = 19)#
#
true.y <- data.frame(y = Exam$normexam, standLRT = Exam$standLRT, school = Exam$school)
setwd("~/Documents/Thesis/Dissertation/sociology_chapter/")#
library(ggplot2)#
library(lme4)     # for modeling#
library(HLMdiag)  # for residuals#
library(mlmRev)   # for the exam data#
library(nullabor) # for lineups#
library(plyr)#
library(reshape2)#
library(stringr)#
#
# Initial model#
M1 <- lmer(normexam ~ standLRT + (1 | school), data = Exam)#
#
# Do we need a random slope? - We can compare the observed data to simulated data#
# to see if the model can generate data that look like the original.#
qplot(x = standLRT, y = normexam, data = Exam, geom = "smooth", group = school, se = F, method = "lm", colour = I("black"))#
#
# The "easy way" with smoothers, but alpha refers to the bands...#
m1.sims  <- simulate(M1, nsim = 19, seed = 1234)#
m1.refit <- lapply(m1.sims, refit, object = M1)#
m1.simy <- lapply(m1.refit, function(x) x@y)#
#
sim.y <- do.call("cbind", m1.simy)#
sim.y <- melt(sim.y)[,-1]#
names(sim.y) <- c(".n", "y")#
sim.y$.n <- as.numeric(str_extract(sim.y$.n, "\\d+"))#
sim.y$standLRT <- rep(Exam$standLRT, rep = 19)#
sim.y$school <- rep(Exam$school, rep = 19)#
#
true.y <- data.frame(y = Exam$normexam, standLRT = Exam$standLRT, school = Exam$school)
The "harder way" to get alpha working#
m1.fitted <- ddply(sim.y, .(.n, school), function(x) {#
	m <- lm(y ~ standLRT, data = x)#
	data.frame(x, fitted = fitted(m))#
})#
#
true.df <- subset(Exam, select = c(school, normexam, standLRT))#
colnames(true.df)[2] <- "y"#
true.fitted <- ddply(true.df, .(school), function(x) {#
	m <- lm(y ~ standLRT, data = x)#
	data.frame(x, fitted = fitted(m))	#
})#
#
qplot(x = standLRT, y = fitted, data = true.fitted, group = school, #
	geom = "line", alpha = I(0.5)) %+% #
	lineup(true = true.fitted, samples = m1.fitted) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) +#
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
		axis.ticks.x = element_blank(), axis.ticks.y = element_blank())#
#	xlab("standardized LRT score") + #
#	ylab("GCSE exam score")
Do we need to allow for correlation? Typically you would add the random effect, then#
# test for the correlation. So that is what we will try.#
M2 <- lmer(normexam ~ standLRT + (standLRT  | school), data = Exam)#
M3 <- lmer(normexam ~ standLRT + (standLRT - 1 | school) + (1 | school), data = Exam)#
#
## The lineup -need to compare simulated ranefs to ranefs of M2#
M3.sims  <- simulate(M3, nsim = 19)#
M3.refit <- lapply(M3.sims, refit, object = M3)#
M3.sim.ranef <- lapply(M3.refit, function(x) ranef(x)[[1]])#
#
M3.sim.ranef <- do.call("rbind", M3.sim.ranef)#
M3.sim.ranef$.n <- rownames(M3.sim.ranef)#
M3.sim.ranef$.n <- as.numeric(str_extract(M3.sim.ranef$.n, "\\d+"))#
#
true.M2.ranef <- ranef(M2)$school#
#
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 E")
ggsave("figures/normexam_corr_lineup6.pdf")
M3.sims2  <- simulate(M3, nsim = 20)
head(M3.sims2)
M3.refit2 <- lapply(M3.sims2[,-20], refit, object = M3)#
M3.sim.ranef2 <- lapply(M3.refit2, function(x) ranef(x)[[1]])
M3.sim.ranef2 <- do.call("rbind", M3.sim.ranef2)#
M3.sim.ranef2$.n <- rownames(M3.sim.ranef2)#
M3.sim.ranef2$.n <- as.numeric(str_extract(M3.sim.ranef2$.n, "\\d+"))
uncorr.mod <- refit(M2, M3.sims2[,20])
uncorr.mod
true.uncorr.ranef <- ranef(uncorr.mod)$school
qplot(x = `(Intercept)`, y = standLRT, data = true.uncorr.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.uncorr.ranef, samples = M3.sim.ranef2) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 E")
ggsave("figures/exam_uncorr_lineup6.pdf")
qplot(x = `(Intercept)`, y = standLRT, data = true.uncorr.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.uncorr.ranef, samples = M3.sim.ranef2) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 FR")
ggsave("figures/exam_uncorr_lineup13.pdf")
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 y")
ggsave("figures/normexam_corr_lineup9.pdf")
fm2 <- lmer(normexam ~ standLRT + I(standLRT^2) + I(standLRT^3) + #
              (1 | school), Exam)
fm2 <- lmer(normexam ~ standLRT + I(standLRT^2) + I(standLRT^3) + #
              (standLRT | school), Exam)
resid1_fm2 <- HLMresid(fm2, level = 1, type = "LS", standardize = "semi")
head(resid1_fm2)
qplot(x = `I(standLRT^2)`, y = semi.std.resid, data = resid1_fm2) + #
  geom_smooth(method = "lm") + #
  ylab("semi-standardized residuals") + #
  xlab("standLRT2")
last_plot
last_plot()
fm2 <- lmer(normexam ~ standLRT + I(standLRT^2) + I(standLRT^3) + #
              (standLRT | school), Exam, REML = FALSE)#
#
## Extract level-1 residuals#
resid1_fm2 <- HLMresid(fm2, level = 1, type = "LS", standardize = "semi")#
head(resid1_fm2)#
#
qplot(x = `I(standLRT^2)`, y = semi.std.resid, data = resid1_fm2) + #
  geom_smooth(method = "lm") + #
  ylab("semi-standardized residuals") + #
  xlab("standLRT2")
resid1_fm2 <- HLMresid(fm2, level = 1, type = "LS", standardize = TRUE)
qplot(x = `I(standLRT^2)`, y = semi.std.resid, data = resid1_fm2) + #
  geom_smooth(method = "lm") + #
  ylab("semi-standardized residuals") + #
  xlab("standLRT2")
head(resid1_fm2)
qplot(x = `I(standLRT^2)`, y = std.resid, data = resid1_fm2) + #
  geom_smooth(method = "lm") + #
  ylab("semi-standardized residuals") + #
  xlab("standLRT2")
qplot(x = `I(standLRT^2)`, y = LS.resid, data = resid1_fm2) + #
  geom_smooth(method = "lm") + #
  ylab("semi-standardized residuals") + #
  xlab("standLRT2")
sim_fm2 <- simulate(fm2, nsim = 19)#
refit_fm2 <- apply(sim_fm2, 2, refit, object = fm2)
Extract level-1 residuals#
sim_fm2_lev1_resid <- ldply(refit_fm2, function(x){#
  HLMresid(object = x, level = 1, type = "LS", sim = x@y, standardize = TRUE)#
})
Labeling for nullabor#
sim_fm2_lev1_resid$.n <- rep(1:19, each = 4059)#
names(sim_fm2_lev1_resid)[4:5] <- c("standLRT2", "standLRT3")
Formatting for nullabor#
lev1_resid_fm2 <- HLMresid(object = fm2, level = 1, type = "LS", standardize = "semi")#
names(lev1_resid_fm2)[3:4] <- c("standLRT2", "standLRT3")#
class(lev1_resid_fm2[,3])  <- "numeric"
qplot(standLRT2, LS.resid, data = lev1_resid_fm2,#
      geom = "point", alpha = I(0.3)) %+%#
  lineup(true = lev1_resid_fm2, samples = sim_fm2_lev1_resid) +#
  facet_wrap(~ .sample, ncol = 4) +#
  geom_hline(aes(yintercept = 0), colour = I("red")) + #
  ylab("semi-standardized residuals")
fm2 <- lmer(normexam ~ standLRT + I(standLRT^2) + I(standLRT^3) + #
              (standLRT | school), Exam, REML = FALSE)#
#
sim_fm2 <- simulate(fm2, nsim = 19)#
refit_fm2 <- apply(sim_fm2, 2, refit, object = fm2)#
#
## Extract level-1 residuals#
sim_fm2_lev1_resid <- ldply(refit_fm2, function(x) #
	data.frame(x@frame, resid = resid(x)))
head(sim_fm2_lev1_resid)
sim_fm2_lev1_resid$.n <- rep(1:19, each = 4059)
names(sim_fm2_lev1_resid)[4:5] <- c("standLRT2", "standLRT3")
lev1_resid_fm2 <- data.frame(fm2@frame, resid = resid(fm2))
names(lev1_resid_fm2)[3:4] <- c("standLRT2", "standLRT3")
class(lev1_resid_fm2[,3])  <- "numeric"
qplot(standLRT2, resid, data = lev1_resid_fm2,#
      geom = "point", alpha = I(0.3)) %+%#
  lineup(true = lev1_resid_fm2, samples = sim_fm2_lev1_resid) +#
  facet_wrap(~ .sample, ncol = 4) +#
  geom_hline(aes(yintercept = 0), colour = I("red")) + #
  ylab("semi-standardized residuals")
qplot(standLRT2, resid, data = lev1_resid_fm2,#
      	geom = "point", alpha = I(0.1)) %+%#
  	lineup(true = lev1_resid_fm2, samples = sim_fm2_lev1_resid) +#
  	facet_wrap(~ .sample, ncol = 4) +#
  	geom_hline(aes(yintercept = 0), colour = I("red")) + #
 	 xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
M1 <- lmer(normexam ~ standLRT + (1 | school), data = Exam)#
#
# Do we need a random slope? - We can compare the observed data to simulated data#
# to see if the model can generate data that look like the original.#
qplot(x = standLRT, y = normexam, data = Exam, geom = "smooth", group = school, se = F, method = "lm", colour = I("black"))#
#
# The "easy way" with smoothers, but alpha refers to the bands...#
m1.sims  <- simulate(M1, nsim = 19, seed = 1234)#
m1.refit <- lapply(m1.sims, refit, object = M1)#
m1.simy <- lapply(m1.refit, function(x) x@y)#
#
sim.y <- do.call("cbind", m1.simy)#
sim.y <- melt(sim.y)[,-1]#
names(sim.y) <- c(".n", "y")#
sim.y$.n <- as.numeric(str_extract(sim.y$.n, "\\d+"))#
sim.y$standLRT <- rep(Exam$standLRT, rep = 19)#
sim.y$school <- rep(Exam$school, rep = 19)#
#
true.y <- data.frame(y = Exam$normexam, standLRT = Exam$standLRT, school = Exam$school)#
#
# qplot(x = standLRT, y = y, data = true.y, group = school, geom = "smooth", #
#	method = "lm", se=F, colour = I("black"), alpha = I(0.5)) %+% #
#	lineup(true = true.y, samples = sim.y) + #
#	facet_wrap( ~ .sample, ncol=5) + #
#	xlab("standardized LRT score") + #
#	ylab("GCSE exam score")#
# The "harder way" to get alpha working#
m1.fitted <- ddply(sim.y, .(.n, school), function(x) {#
	m <- lm(y ~ standLRT, data = x)#
	data.frame(x, fitted = fitted(m))#
})#
#
true.df <- subset(Exam, select = c(school, normexam, standLRT))#
colnames(true.df)[2] <- "y"#
true.fitted <- ddply(true.df, .(school), function(x) {#
	m <- lm(y ~ standLRT, data = x)#
	data.frame(x, fitted = fitted(m))	#
})#
#
qplot(x = standLRT, y = fitted, data = true.fitted, group = school, #
	geom = "line", alpha = I(0.5)) %+% #
	lineup(true = true.fitted, samples = m1.fitted) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) +#
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
		axis.ticks.x = element_blank(), axis.ticks.y = element_blank())#
#	xlab("standardized LRT score") + #
#	ylab("GCSE exam score")#
#
#-------------------------------------------------------------------------------#
# Lineups to test for need for correlated random effects#
#-------------------------------------------------------------------------------#
#
# Do we need to allow for correlation? Typically you would add the random effect, then#
# test for the correlation. So that is what we will try.#
M2 <- lmer(normexam ~ standLRT + (standLRT  | school), data = Exam)#
M3 <- lmer(normexam ~ standLRT + (standLRT - 1 | school) + (1 | school), data = Exam)#
#
## The lineup -need to compare simulated ranefs to ranefs of M2#
M3.sims  <- simulate(M3, nsim = 19)#
M3.refit <- lapply(M3.sims, refit, object = M3)#
M3.sim.ranef <- lapply(M3.refit, function(x) ranef(x)[[1]])#
#
M3.sim.ranef <- do.call("rbind", M3.sim.ranef)#
M3.sim.ranef$.n <- rownames(M3.sim.ranef)#
M3.sim.ranef$.n <- as.numeric(str_extract(M3.sim.ranef$.n, "\\d+"))#
#
true.M2.ranef <- ranef(M2)$school#
#
qplot(x = `(Intercept)`, y = standLRT, data = true.M2.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.M2.ranef, samples = M3.sim.ranef) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())#
## A simulation when we know that we DO NOT need correlation#
M3.sims2  <- simulate(M3, nsim = 20)#
M3.refit2 <- lapply(M3.sims2[,-20], refit, object = M3)#
M3.sim.ranef2 <- lapply(M3.refit2, function(x) ranef(x)[[1]])#
#
M3.sim.ranef2 <- do.call("rbind", M3.sim.ranef2)#
M3.sim.ranef2$.n <- rownames(M3.sim.ranef2)#
M3.sim.ranef2$.n <- as.numeric(str_extract(M3.sim.ranef2$.n, "\\d+"))#
#
uncorr.mod <- refit(M2, M3.sims2[,20])#
true.uncorr.ranef <- ranef(uncorr.mod)$school#
#
qplot(x = `(Intercept)`, y = standLRT, data = true.uncorr.ranef, #
	geom = c("point", "smooth"), method = "lm", se = F, alpha = I(0.4)) %+% #
	lineup(true = true.uncorr.ranef, samples = M3.sim.ranef2) + #
	facet_wrap( ~ .sample, ncol=5) + #
	xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())#
#
#-------------------------------------------------------------------------------#
# Lineup to test for level-1 heteroscedasticity#
#-------------------------------------------------------------------------------#
#
fm2 <- lmer(normexam ~ standLRT + I(standLRT^2) + I(standLRT^3) + #
              (standLRT | school), Exam, REML = FALSE)#
#
sim_fm2 <- simulate(fm2, nsim = 19)#
refit_fm2 <- apply(sim_fm2, 2, refit, object = fm2)#
#
## Extract level-1 residuals#
sim_fm2_lev1_resid <- ldply(refit_fm2, function(x) #
	data.frame(x@frame, resid = resid(x)))#
#
## Labeling for nullabor#
sim_fm2_lev1_resid$.n <- rep(1:19, each = 4059)#
names(sim_fm2_lev1_resid)[4:5] <- c("standLRT2", "standLRT3")#
#
## Formatting for nullabor#
lev1_resid_fm2 <- data.frame(fm2@frame, resid = resid(fm2))#
names(lev1_resid_fm2)[3:4] <- c("standLRT2", "standLRT3")#
class(lev1_resid_fm2[,3])  <- "numeric"#
#
## Creating lineup#
qplot(standLRT2, resid, data = lev1_resid_fm2,#
      	geom = "point", alpha = I(0.3)) %+%#
  	lineup(true = lev1_resid_fm2, samples = sim_fm2_lev1_resid) +#
  	facet_wrap(~ .sample, ncol = 4) +#
  	geom_hline(aes(yintercept = 0), colour = I("red")) + #
 	 xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 d")
ggsave("figured/normexam_constvar_lineup2.pdf")
ggsave("figure/normexam_constvar_lineup2.pdf")
ggsave(filename="figure/normexam_constvar_lineup2.pdf")
dir()
qplot(standLRT2, resid, data = lev1_resid_fm2,#
      	geom = "point", alpha = I(0.3)) %+%#
  	lineup(true = lev1_resid_fm2, samples = sim_fm2_lev1_resid) +#
  	facet_wrap(~ .sample, ncol = 4) +#
  	geom_hline(aes(yintercept = 0), colour = I("red")) + #
 	 xlab(NULL) + ylab(NULL) + #
	theme(axis.text.y = element_blank(), axis.text.x = element_blank(),#
	axis.ticks.x = element_blank(), axis.ticks.y = element_blank())
decrypt("P2SX 6lal Y8 5GhYaYG8 9")
ggsave(filename="figures/normexam_constvar_lineup5.pdf")
setwd("~/Documents/Thesis/Dissertation/sociology_chapter/")#
library(ggplot2)#
library(lme4)     # for modeling#
library(HLMdiag)  # for residuals#
library(WWGbook)  # for half of data set - see ?autism#
library(nullabor) # for lineups#
library(plyr)#
library(reshape2)#
library(stringr)#
#
# Function to make lineups for explanatory variables less tedious - level 1#
data.lineup.explvar1 <- function(null.model, variable, data, nsim = 19, std = FALSE) {#
	mod.sims  <- simulate(null.model, nsim = nsim)#
	mod.refit <- lapply(mod.sims, refit, object = null.model)#
	if(std){#
		mod.sim.resid <- lapply(mod.refit, HLMresid, level = 1, #
			type = "EB", standardize = TRUE)#
	} else{#
		mod.sim.resid <- lapply(mod.refit, resid)#
	}#
#
	mod.sim.resid <- do.call("cbind", mod.sim.resid)#
	mod.sim.resid <- melt(mod.sim.resid)[,-1]#
	names(mod.sim.resid) <- c(".n", "residual")#
	mod.sim.resid$.n <- as.numeric(str_extract(mod.sim.resid $.n, "\\d+"))#
	mod.sim.resid <- cbind(mod.sim.resid, data[, variable])#
	names(mod.sim.resid)[-c(1:2)] <- variable#
	return(mod.sim.resid)#
}#
#
# Function to make lineups for explanatory variables less tedious - level 2#
data.lineup.explvar2 <- function(null.model, variable, data, nsim = 19) {#
	mod.sims  <- simulate(null.model, nsim = nsim)#
	mod.refit <- lapply(mod.sims, refit, object = null.model)#
	mod.sim.resid <- lapply(mod.refit, HLMresid, level = "childid")#
#
	mod.sim.resid <- do.call("rbind", mod.sim.resid)#
	mod.sim.resid$.n <- as.numeric(str_extract(rownames(mod.sim.resid), "\\d+"))#
	mod.sim.resid$childid <- str_extract(rownames(mod.sim.resid), "[.]\\d+")#
	mod.sim.resid$childid <- as.numeric(str_extract(mod.sim.resid$childid, "\\d+"))#
	mod.sim.resid <- cbind(mod.sim.resid, data[, variable])#
	names(mod.sim.resid)[-c(1:4)] <- variable#
	return(mod.sim.resid)#
}#
# Reading in more of the autism data set#
demographics <- read.csv("data/autism_demographics.csv")#
#
# combining the data sets#
autism.full <- merge(x = autism, y = demographics, by.x = c("childid", "sicdegp"),#
	by.y = c("newinit", "sicdegp"), all.x = TRUE)#
# Creating factors where necessary#
autism.full$sicdegp  <- factor(autism.full$sicdegp, labels = c("low", "med", "high"))#
autism.full$gender   <- factor(autism.full$gender, labels = c("male", "female"))#
autism.full$race     <- factor(autism.full$race, labels = c("white", "nonwhite"))#
autism.full$bestest2 <- factor(autism.full$bestest2, labels = c("autism", "pdd"))#
#
# Center age at 2 years to interpret the intercept#
autism.full$age2 <- autism.full$age - 2#
#
# Taking the complete cases for our example#
autism.modframe <- subset(autism.full, #
	select = c(childid, sicdegp, age2, vsae, gender, race, bestest2))#
autism.modframe <- na.omit(autism.modframe)
M1 <- lmer(vsae ~ age2 + ( age2 - 1 | childid ), data = autism.modframe)
M1
FC <- function(.mod, .L) {#
	       y <- .mod@y#
           X <- getME(.mod, "X")#
           Z <- BlockZ(.mod)#
           n <- nrow(X)#
           p <- ncol(X)#
           ngrps <- unname( summary(.mod)@ngrps )#
           vc <- VarCorr(.mod)#
           Di <- bdiag( VarCorr(.mod) ) / (unname(attr(vc, "sc")))^2#
           D  <- kronecker( Diagonal(ngrps), Di )#
           Aslot <- .mod@A # ZDZ'#
           zdzt <- crossprod( .mod@A )#
           V  <- Diagonal( n ) + zdzt#
           V.chol <- chol( V )#
           Vinv  <- chol2inv( V.chol ) #
           XVXinv <- solve( t(X) %*% Vinv %*% X )#
           VinvX  <- Vinv %*% X#
           M      <- VinvX %*% XVXinv %*% t(VinvX)#
           P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
           pzdl <- P %*% Z %*% D %*% .L#
           A <- as.matrix( crossprod( pzdl ) )#
           B <- as.matrix( t(.L) %*% D %*% t(Z) %*% P %*% Z %*% D %*% .L ) ## diagnostic se#
           RVAL <- try( mean( diag( ginv(B) %*% (A) ) ) )#
           if( class(RVAL) == "try-error" ) RVAL <- NA#
           return( RVAL )#
}
FC(M1, Diagonal(155))
Function to reorganize Z#
BlockZ <- function(object) {#
  Z <- getME(object, "Z")#
  grp.size <- table(object@flist)#
  ngrps <- length(grp.size)#
  nranef <- dim(ranef(object)[[1]])[2]#
  base.ord <- seq(from = 1, by = ngrps, length.out = nranef)#
  ord <- base.ord + rep(0:(ngrps - 1), each = nranef)#
  perm.mat <- t(as(ord, "pMatrix"))#
  return(Z %*% perm.mat)#
}
FC(M1, Diagonal(155))
library(RcppEigen)
library(inline)
source('~/Documents/Thesis/Dissertation/eresids-chapter/simulations/functions/cpp_functions.R')
FC(M1, Diagonal(155))
